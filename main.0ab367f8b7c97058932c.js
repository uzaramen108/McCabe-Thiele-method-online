"use strict";(self.webpackChunkmccabe_thiele_method_online=self.webpackChunkmccabe_thiele_method_online||[]).push([[792],{374:()=>{class e{xd;xb;zf;q;r_factor;nm;sc;constructor(){this.xd=parseFloat(document.getElementById("xd").value),this.xb=parseFloat(document.getElementById("xb").value),this.zf=parseFloat(document.getElementById("zf").value),this.q=parseFloat(document.getElementById("q").value),this.r_factor=parseFloat(document.getElementById("r_factor").value),this.nm=parseFloat(document.getElementById("nm").value),this.sc=parseFloat(document.getElementById("sub_cooling").value),this.validate()}validate(){return[this.xd,this.xb,this.zf,this.q,this.r_factor,this.nm,this.sc].some(e=>isNaN(e))?(console.error("입력값 오류: 일부 값이 숫자가 아닙니다 (NaN).",this),alert("유효하지 않은 입력값이 있습니다. 숫자만 입력해주세요."),!1):((this.xd<=this.zf||this.zf<=this.xb)&&console.warn(`입력값 경고: 조성 순서가 올바르지 않습니다 (xd > zf > xb 여야 함). xd=${this.xd}, zf=${this.zf}, xb=${this.xb}`),!0)}}const t=[{x:0,y:0},{x:.012,y:.068},{x:.02,y:.121},{x:.026,y:.159},{x:.033,y:.188},{x:.036,y:.215},{x:.053,y:.275},{x:.076,y:.366},{x:.1,y:.438},{x:.12,y:.485},{x:.14,y:.522},{x:.15,y:.541},{x:.2,y:.605},{x:.3,y:.686},{x:.4,y:.739},{x:.5,y:.779},{x:.6,y:.825},{x:.7,y:.87},{x:.8,y:.915},{x:.9,y:.958},{x:.95,y:.979},{x:1,y:1}];function n(e){if(e<=0)return 0;if(e>=1)return 1;let n=t[0],s=t[1];for(let o=1;o<t.length;o++)if(t[o].x>=e){n=t[o-1],s=t[o];break}const o=(s.y-n.y)/(s.x-n.x);return n.y+(e-n.x)*o}function s(e,t){if(t<=e[0].y)return e[0].x;if(t>=e[e.length-1].y)return e[e.length-1].x;let n=0,s=e.length-1,o=e[n],l=e[s];for(;s-n>1;){let o=Math.floor((n+s)/2);e[o].y<t?n=o:s=o}o=e[n],l=e[s];const i=(l.x-o.x)/(l.y-o.y);return o.x+(t-o.y)*i}const o=document.getElementById("calc-form"),l=document.getElementById("mccabeThieleChart"),i=document.getElementById("results-text"),a=l.getContext("2d");function r(){try{const t=new e,{plotData:o,results:r,floatStageNum:c}=function(e){const{xd:t,xb:o,zf:l,q:i,r_factor:a,nm:r,sc:c}=e,x={ideal_eq_curve:[],line_45:[{x:0,y:0},{x:1,y:1}],q_line:[],esol_line:[],ssol_line:[],steps:[],effective_curve:[]},d={R_min:0,R:0,stages:0,feed_stage:0,xb_actual:0},{x:f,y:u}=function(e,t){if(Math.abs(e-1)<1e-6)return{x:t,y:n(t)};if(Math.abs(e)<1e-6){const e=function(e){let t,s=0,o=1;for(let l=0;l<30;l++)t=(s+o)/2,n(t)<e?s=t:o=t;return(s+o)/2}(t);return{x:e,y:t}}const s=e/(e-1),o=-t/(e-1),l=e=>n(e)-(e=>s*e+o)(e);let i,a=0,r=1;for(let e=0;e<30;e++)i=(a+r)/2,l(i)<0?a=i:r=i;const c=(a+r)/2;return{x:c,y:n(c)}}(i,l),y=(t-u)/(t-f);d.R_min=y/(1-y),d.R=d.R_min*a;let h=d.R;const m=1+81.6*c/35270;h=d.R*m;const _=h/(h+1),g=t/(h+1);let b,v;Math.abs(i-1)<1e-6?(b=l,v=_*b+g):(b=(g- -l/(i-1))/(i/(i-1)-_),v=_*b+g);const p=(v-o)/(b-o),F=o-p*o;x.q_line=[{x:l,y:l},{x:f,y:u}],x.esol_line=[{x:t,y:t},{x:b,y:v}],x.ssol_line=[{x:o,y:o},{x:b,y:v}];const k=e=>_*e+g,$=e=>p*e+F;for(let e=0;e<=100;e++){const t=e/100,s=n(t);x.ideal_eq_curve.push({x:t,y:s});const o=k(t),l=o+r*(s-o);t>b&&x.effective_curve.push({x:t,y:l});const i=$(t),a=i+r*(s-i);t<=b&&x.effective_curve.push({x:t,y:a})}let E=t,R=t,z=0,I=0;for(;E>o&&z<200;){let e;z++;const t=R;let n;if(e=s(x.effective_curve,R),e>b?n=k(e):(n=$(e),0===d.feed_stage&&(d.feed_stage=z)),x.steps.push([{x:E,y:t},{x:e,y:t}]),x.steps.push([{x:e,y:t},{x:e,y:n}]),e<o){I=z+(E-o)/(E-e);break}E=e,R=n}return 0===d.feed_stage&&(d.feed_stage=1),d.stages=z,d.xb_actual=E,{plotData:x,results:d,floatStageNum:I}}(t);!function(e,t){const n=`\n    -- 계산 결과 (Results) --\n    최소 환류비 (R_min)   : ${e.R_min.toFixed(3)}\n    실제 환류비 (R)       : ${e.R.toFixed(3)} (R_min의 ${document.getElementById("r_factor").value}배)\n    \n    총 이론 단 수 (Stages): ${e.stages}(${t.toFixed(1)}) 단\n    최적 공급 단 (Feed @) : ${e.feed_stage} 번째 단 (from top)\n    \n    실제 하부 조성 (xb_actual): ${e.xb_actual.toFixed(5)}\n    (목표 하부 조성: ${document.getElementById("xb").value})\n    `;i.textContent=n}(r,c),function(t){if(!a||!l)return;a.clearRect(0,0,l.width,l.height);const n=Math.min(l.width,l.height),s=n-80,o=e=>40+e*s,i=e=>40+(1-e)*s;a.strokeStyle="#333",a.lineWidth=1,a.font="10px Arial",a.textAlign="center",a.beginPath(),a.moveTo(o(0),i(0)),a.lineTo(o(1),i(0)),a.stroke(),a.beginPath(),a.moveTo(o(0),i(0)),a.lineTo(o(0),i(1)),a.stroke(),a.strokeStyle="grey",a.beginPath(),a.moveTo(o(0),i(0)),a.lineTo(o(1),i(1)),a.stroke();const r=(e,t,n,s=[])=>{if(a.strokeStyle=t,a.lineWidth=n,a.setLineDash(s),0!==e.length){a.beginPath(),a.moveTo(o(e[0].x),i(e[0].y));for(let t=1;t<e.length;t++)a.lineTo(o(e[t].x),i(e[t].y));a.stroke(),a.setLineDash([])}};r(t.ideal_eq_curve,"blue",2),r(t.effective_curve,"#00c000",2,[5,5]),r(t.q_line,"orange",2),r(t.esol_line,"#6a5acd",2),r(t.ssol_line,"#6a5acd",2),a.strokeStyle="#FF6384",a.lineWidth=1.5,t.steps.forEach(e=>{2===e.length&&(a.beginPath(),a.moveTo(o(e[0].x),i(e[0].y)),a.lineTo(o(e[1].x),i(e[1].y)),a.stroke())});const c=(e,t,n,s)=>{const l=o(e),r=i(t);a.fillStyle=n,a.beginPath(),a.arc(l,r,4,0,2*Math.PI),a.fill(),a.fillStyle="#000",a.textAlign="left",a.fillText(s,l+6,r)},x=new e;c(x.xd,x.xd,"red",`xd (${x.xd.toFixed(3)})`),c(x.xb,x.xb,"red",`xb (${x.xb.toFixed(3)})`),c(x.zf,0,"black",`zf (${x.zf.toFixed(3)})`)}(o)}catch(e){console.error("McCabe-Thiele 계산 중 오류 발생:",e),alert(`계산에 실패했습니다: ${e.message}\n콘솔(F12)에서 자세한 내용을 확인하세요.`),i.textContent=`계산 오류:\n${e.message}`}}o.addEventListener("submit",e=>{e.preventDefault(),r()}),document.addEventListener("DOMContentLoaded",()=>{console.log("페이지 로드 완료. 기본값으로 첫 계산을 실행합니다."),r()})}},e=>{e(e.s=374)}]);
//# sourceMappingURL=main.0ab367f8b7c97058932c.js.map